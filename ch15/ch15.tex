\input{../tex_header}

\title{Chapter 15 Solusion}
\date{11/3/2021}

\begin{document}
\maketitle

\section*{15.1}

\subsection*{15.1-1}

\begin{proof}
    We prove by substitution method.
    For $n=0$, $T(0)=2^0=1$.
    For $n>0$,

    $T(n)=1+\sum\limits_{j=0}^{n-1}T(j)
    =1+\sum\limits_{j=0}^{n-1}2^j=1+(2^n-1)=2^n$
\end{proof}

\subsection*{15.1-2}

Consider the following case:

\begin{tabular}{c||c|c|c}
    length $i$      & 1 & 2 & 3 \\
    price $p_i$     & 1 & 6 & 8 \\
    density $p_i/i$ & 1 & 3 & 2.67
\end{tabular}

\noindent
If we use "greedy" strategy, our solution will be ``$2$ $1$'',
and the total price will be $7$.
However, the optimal way is ``$3$'', and the total price is $8$.

\subsection*{15.1-3}

\begin{minted}[xleftmargin=20pt,linenos]{cpp}
    /**
    * running time: O(n^2)
    * p: table of prices (index start from 0)
    * n: length of rod
    * c: cost of each cut
    * return maximum revenue
    */
    int BottomUpCutRodWithCost(const std::vector<int>& p, int n, int c)
    {
        int *r, q, i, j;
        r = new int[n + 1];
        r[0] = 0;
        for (j = 1; j <= n; ++j)
        {
            q = p[j - 1];
            for (i = 0; i < j - 1; ++i)
                q = std::max(q, p[i] + r[j - i - 1] - c);
            r[j] = q;
        }
        delete[] r;
        return q;
    }
\end{minted}

\subsection*{15.1-4}

\begin{minted}[xleftmargin=20pt,linenos]{cpp}
    /**
    * p: table of prices (index start from 0)
    * n: length of rod
    * r: table of maximum revenue (index start from 1)
    * s: table of optimal size i of the first piece to cut off (index start from 1)
    * return maximum revenue
    */
    int ExtendedMemoizedCutRodAux(const std::vector<int>& p, int n, int *r, int *s)
    {
        int q, i, reminder_r;
        if (r[n] >= 0) return r[n];
        q = INT_MIN;
        for (i = 0; i < n; ++i)
        {
            reminder_r = ExtendedMemoizedCutRodAux(p, n - i - 1, r, s);
            if (q < p[i] + reminder_r)
            {
                q = p[i] + reminder_r;
                s[n] = i + 1;
            }
        }
        r[n] = q;
        return q;
    }

    /**
    * running time: O(n^2)
    * p: table of prices (index start from 0)
    * n: length of rod
    * return (r, s)
    * r: table of maximum revenue (index start from 1)
    * s: table of optimal size i of the first piece to cut off (index start from 1)
    * caller is responsible to deallocate return value r and s
    */
    std::pair<int*, int*> ExtendedMemoizedCutRod(const std::vector<int>& p, int n)
    {
        int *r, *s, i;
        r = new int[n + 1];
        s = new int[n + 1];
        r[0] = 0;
        s[0] = 0;
        for (i = 1; i <= n; ++i) r[i] = INT_MIN;
        ExtendedMemoizedCutRodAux(p, n, r, s);
        return std::make_pair(r, s);
    }
\end{minted}

\subsection*{15.1-5}

\begin{minted}[xleftmargin=20pt,linenos]{cpp}
    /**
    * running time: O(n)
    * n: n-th fibonacci number (must greater than 0)
    */
    int FibonacciNumber(int n)
    {
        int *f, i, result;
        f = new int[n + 1];
        f[0] = 0;
        f[1] = 1;
        for (i = 2; i <= n; ++i)
            f[i] = f[i - 1] + f[i - 2];
        result = f[n];
        delete[] f;
        return result;
    }
\end{minted}

\end{document}
