\input{../tex_header}

\title{Chapter 14 Solusion}
\date{10/20/2021}

\begin{document}
\maketitle

\section*{14.1}

\subsection*{14.1-1}

\begin{tabular}{c|c|c|c}
    recursion & $x.key$ & $r$ & $i$\\
    \hline
    1 & 26 & 13 & 10 \\
    2 & 17 & 8 & 10 \\
    3 & 21 & 3 & 2 \\
    4 & 19 & 1 & 2 \\
    5 & 20 & 1 & 1
\end{tabular}

The result is $20$.

\subsection*{14.1-2}

\begin{tabular}{c|c|c}
    iteration & $y.key$ & $r$ \\
    \hline
    1 & 35 & 1 \\
    2 & 38 & 1 \\
    3 & 30 & 3 \\
    4 & 41 & 3 \\
    5 & 26 & 16
\end{tabular}

The result is $16$.

\subsection*{14.1-3}

\begin{minted}[xleftmargin=20pt,linenos]{cpp}
    template <class Key, class T>
    typename AugmentRedBlackTree<Key, T>::Node* AugmentRedBlackTree<Key, T>::Select
        (Node* subtree_root_node, size_t rank)
    {
        size_t root_rank;
        root_rank = subtree_root_node->left->size + 1;
        while (rank != root_rank)
        {
            if (rank < root_rank) 
            {
                subtree_root_node = subtree_root_node->left;
            }
            else 
            {
                subtree_root_node = subtree_root_node->right;
                rank -= root_rank;
            }
            root_rank = subtree_root_node->left->size + 1;
        }
        return subtree_root_node;
    } 
\end{minted}

\subsection*{14.1-4}

\begin{minted}[xleftmargin=20pt,linenos]{cpp}
    template <class Key, class T>
    size_t AugmentRedBlackTree<Key, T>::Rank(Node* node)
    {
        if (node == root_)
            return node->left->size + 1;
        else if (node == node->parent->left)
            return Rank(node->parent) - node->right->size - 1;
        else
            return Rank(node->parent) + node->left->size + 1;
    }
\end{minted}

\subsection*{14.1-5}

\begin{codebox}
    \li $\id{r} \gets \proc{OS-Rank}(T, x)$
    \li $\id{succ} \gets \proc{OS-Select}(T.root, r + i)$
\end{codebox}

The result is $succ$.

\subsection*{14.1-6}

\noindent
For $\proc{RB-Insert}(T, z)$,
set $\attrib{z}{rank} \gets 1$,
and change the while loop to the following code:

\begin{codebox}
    \li \While $x \neq \attrib{T}{nil}$
    \li \Do
            $y \gets x$
    \li     \If $\attrib{z}{key} < \attrib{x}{key}$
    \li     \Then
                $\attrib{x}{rank} \gets \attrib{x}{rank} + 1$
    \li         $x \gets \attrib{x}{left}$
    \li     \Else
                $x \gets \attrib{x}{right}$
            \End
        \End
\end{codebox}

\noindent
For $\proc{RB-Delete}(T, z)$,
add the following code right befire line 18 (in the else branch):

\begin{codebox}
    \zi $\attrib{y}{rank} \gets \attrib{z}{rank}$
\end{codebox}

\noindent
And invoke $\proc{RB-Delete-Fix-Rank}(T, x)$ right before line 21.

\begin{codebox}
    \Procname{$\proc{RB-Delete-Fix-Rank}(T, x)$}
    \li \While $x \neq \attrib{T}{root}$
    \li \Do
        \If $x \isequal \attribb{x}{p}{left}$
    \li \Then
            $\attribb{x}{p}{rank} \gets \attribb{x}{p}{rank} - 1$
        \End
    \li $x \gets \attrib{x}{p}$
        \End
\end{codebox}

\noindent
For $\proc{Left-Rotate}(T, x)$,
add the following code to the end of the procedure:

\begin{codebox}
    \zi $\attrib{y}{rank} = \attrib{y}{rank} + \attrib{x}{rank}$
\end{codebox}

\noindent
For $\proc{Right-Rotate}(T, y)$,
add the following code to the end of the procedure:

\begin{codebox}
    \zi $\attrib{y}{rank} = \attrib{y}{rank} - \attrib{x}{rank}$
\end{codebox}

\subsection*{14.1-7}

\begin{minted}[xleftmargin=20pt,linenos]{cpp}
    template <typename Key>
    size_t CountInversions(std::vector<Key> array)
    {
        size_t inversions, i, rank;
        AugmentRedBlackTree<Key, int> tree;
        std::pair<typename AugmentRedBlackTree<Key, int>::Iterator, bool> insert_result;
        inversions = 0;
        for (i = 0; i < array.size(); ++i)
        {
            insert_result = tree.Insert({array[i], 0});
            rank = tree.Rank(insert_result.first);
            inversions += (1 + i - rank); 
        }
        return inversions;
    }
\end{minted}

\subsection*{14.1-8}

\begin{minted}[xleftmargin=20pt,linenos]{cpp}
    size_t CountIntersections(std::vector<Chord> chords)
    {
        size_t intersections, i, rank_a, rank_b, rank_diff_1, rank_diff_2;
        OSTree tree;
        std::pair<typename OSTree::Iterator, bool> insert_result_a, insert_result_b;
        intersections = 0;
        for (i = 0; i < chords.size(); ++i)
        {
            insert_result_a = tree.Insert({chords[i].endpoint_a, 0});
            insert_result_b = tree.Insert({chords[i].endpoint_b, 0});
            rank_a = tree.Rank(insert_result_a.first);
            rank_b = tree.Rank(insert_result_b.first);
            if (rank_a > rank_b) std::swap (rank_a, rank_b);
            // rank_a must smaller than rank_b
            rank_diff_1 = rank_b - rank_a - 1;
            rank_diff_2 = tree.Size() - rank_b + rank_a - 1;
            intersections += std::min(rank_diff_1, rank_diff_2); 
        }
        return intersections;
    }
\end{minted}

\section*{14.2}

\subsection*{14.2-1}

\noindent
Add $\id{prev}$ and $\id{succ}$ attributes to each node in the tree.
Let $\id{prev}$ points to predecessor of the node, 
and let $\id{succ}$ points to successor of the node.
Let $\attribb{T}{nil}{succ}$ points to the minumum element in the tree,
and let $\attribb{T}{nil}{prev}$ points to the maximum element in the tree.
A circular doubly linked list is formed.

\noindent
In order to maintain these informations,
we just need to modify $\proc{RB-Insert}$ and $\proc{RB-Delete}$.

\noindent
For $\proc{RB-Insert}(T, z)$, modify line 9 - 13 to the following code:

\begin{codebox}
    \li \If $y \isequal \attrib{T}{nil}$
    \li \Then
            $\attrib{T}{root} \gets z$
    \li     $\attrib{z}{succ} \gets \attrib{T}{nil}$
    \li     $\attrib{z}{prev} \gets \attrib{T}{nil}$
    \li \ElseIf $\attrib{z}{key} < \attrib{y}{key}$
    \li \Then
            $\attrib{y}{left} \gets z$
    \li     $\attrib{z}{succ} \gets y$
    \li     $\attrib{z}{prev} \gets \attrib{y}{prev}$
    \li \Else
            $\attrib{y}{right} \gets z$
    \li     $\attrib{z}{prev} \gets y$
    \li     $\attrib{z}{succ} \gets \attrib{y}{succ}$
        \End
    \li     $\attribb{z}{succ}{prev} \gets z$
    \li     $\attribb{z}{prev}{succ} \gets z$
\end{codebox}

\noindent
For $\proc{RB-Delete}(T, z)$, 
add the following code right before line 21:

\begin{codebox}
    \li $\attribb{z}{prev}{succ} \gets \attrib{z}{succ}$
    \li $\attribb{z}{succ}{prev} \gets \attrib{z}{prev}$
\end{codebox}

\subsection*{14.2-2}

\noindent
We can maintain black-heights of nodes without affecting the asymptotic performance
since a change to $\attrib{x}{bh}$ propagates only to ancestors of $x$ in the tree.

\noindent
For $\proc{RB-Insert}(T, z)$, 
add the following code right before line 17:

\begin{codebox}
    \zi $\attrib{z}{bh} \gets 1$
\end{codebox}

\noindent
For $\proc{RB-Insert-Fixup}(T, z)$, 
add the following code right before line 8 (in the if branch) (case 1):

\begin{codebox}
    \zi $\attribbb{z}{p}{p}{bh} \gets \attribbb{z}{p}{p}{bh} + 1$
\end{codebox}

\noindent
For $\proc{RB-Delete-Fixup}(T, z)$, 
add the following code right before line 11 (in the if branch) (case 2):

\begin{codebox}
    \zi $\attribb{x}{p}{bh} \gets \attribb{x}{p}{bh} - 1$
\end{codebox}

\noindent
And add the following code right before line 21 (in the else branch) (case 4):

\begin{codebox}
    \zi $\attribb{x}{p}{bh} \gets \attribb{x}{p}{bh} - 1$
    \zi $\attribbb{x}{p}{p}{bh} \gets \attribbb{x}{p}{p}{bh} + 1$
\end{codebox}

\noindent
We cannot maintain depths of nodes without affecting the asymptotic performance
since a change to $\attrib{x}{bh}$ propagates to descendants of $x$ in the tree.

\subsection*{14.2-3}

\noindent
After the rotation on $x$ is performed, run the following code:

\begin{codebox}
    \li $\attribb{x}{p}{f} \gets \attrib{x}{f}$
    \li $\attrib{x}{f} \gets \attribb{x}{left}{f} \otimes \attribb{x}{right}{f} \otimes \attrib{x}{a}$
\end{codebox}

\noindent
Apply to the $size$ attributes in order-statistic trees, 
we just need to change $f$ to $size$, change $\otimes$ to $+$, and attibute $a$ of each node will be $1$;
the code will be:

\begin{codebox}
    \li $\attribb{x}{p}{size} \gets \attrib{x}{size}$
    \li $\attrib{x}{size} \gets \attribb{x}{left}{size} + \attribb{x}{right}{size} + 1$
\end{codebox}

\subsection*{14.2-4}

\noindent
The following procedure takes $\Theta(m+\log(n))$ time 
(to understand this asymptotic performance, refer to theorem 12.1 and exercise 12.2-8):

\begin{codebox}
    \Procname{$\proc{RB-Enumerate}(x, a, b)$}
    \li \If $a \leq \attrib{x}{key}$ and $\attrib{x}{key} \leq b$
    \li \Then
            $\proc{Output}(x)$
        \End
    \li \If $a \leq \attrib{x}{key}$ and $\attrib{x}{left} \neq \attrib{T}{nil}$
    \li \Then
            $\proc{RB-Enumerate}(\attrib{x}{left}, a, b)$
        \End
    \li \If $\attrib{x}{key} \leq b$ and $\attrib{x}{right} \neq \attrib{T}{nil}$
    \li \Then
            $\proc{RB-Enumerate}(\attrib{x}{right}, a, b)$
        \End
\end{codebox}

\noindent
Note that we need to implement $\proc{RB-Enumerate}(x, a, b)$ in $\Theta(m+\log(n))$ time,
so it does not meet the requirement of the question
if we implement the procedure in the following ways (augment the tree in the way of exercise 14.2-1) 
since it takes $\Theta(m)$ time only:

\begin{codebox}
    \Procname{$\proc{RB-Enumerate}(T, a, b)$}
    \li $k \gets a$
    \li $\proc{Output}(k)$
    \li \Repeat
    \li     $k \gets \attrib{k}{succ}$
    \li     $\proc{Output}(k)$
    \li \Until $k \isequal b$
\end{codebox}

\end{document}
